First, let's create a utility file to store common functions and constants that we'll use throughout the project. This file will help us keep our code organized and maintainable.

```tsx file="lib/utils.ts"
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
```

Next, let's create a ThemeProvider component that will handle the theme context for our application. This component will allow us to switch between light and dark themes easily.

```tsx file="components/theme-provider.tsx"
"use client"
import { ThemeProvider as NextThemesProvider, type ThemeProviderProps } from "next-themes"

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>
}
```

Now, let's create a CelebrationAnimation component that will display fun animations when the user reaches their daily water intake goal. This component will add an element of gamification to the water intake tracking experience.

```tsx file="components/celebration-animation.tsx"
"use client"

import { useEffect, useState } from "react"
import confetti from "canvas-confetti"
import { Award } from "lucide-react"

export default function CelebrationAnimation() {
  const [mounted, setMounted] = useState(false)

  useEffect(() => {
    setMounted(true)

    // Trigger confetti
    const duration = 3 * 1000
    const animationEnd = Date.now() + duration
    const defaults = { startVelocity: 30, spread: 360, ticks: 60, zIndex: 0 }

    function randomInRange(min: number, max: number) {
      return Math.random() * (max - min) + min
    }

    const interval = setInterval(() => {
      const timeLeft = animationEnd - Date.now()

      if (timeLeft <= 0) {
        return clearInterval(interval)
      }

      const particleCount = 50 * (timeLeft / duration)

      // Since particles fall down, start a bit higher than random
      confetti({
        ...defaults,
        particleCount,
        origin: { x: randomInRange(0.1, 0.3), y: Math.random() - 0.2 },
      })
      confetti({
        ...defaults,
        particleCount,
        origin: { x: randomInRange(0.7, 0.9), y: Math.random() - 0.2 },
      })
    }, 250)

    return () => clearInterval(interval)
  }, [])

  if (!mounted) return null

  return (
    <div className="fixed inset-0 flex items-center justify-center pointer-events-none z-50">
      <div className="bg-primary/90 text-primary-foreground rounded-full p-6 md:p-8 animate-bounce shadow-lg">
        <div className="flex flex-col items-center">
          <Award className="h-10 w-10 md:h-12 md:w-12 mb-2" />
          <h2 className="text-lg md:text-xl font-bold">Goal Reached!</h2>
          <p className="text-sm md:text-base">Great job staying hydrated!</p>
        </div>
      </div>
    </div>
  )
}
```

Next, let's create a CupSelector component that will allow users to select the size of the cup they are using to track their water intake. This component will provide a visual representation of the cup size and make it easy for users to track their progress.

```tsx file="components/cup-selector.tsx"
"use client"

import { Button } from "@/components/ui/button"
import { cn } from "@/lib/utils"

interface CupSize {
  id: string
  name: string
  amount: number
  icon: string
}

interface CupSelectorProps {
  cupSizes: CupSize[]
  selectedCup: CupSize
  onSelectCup: (cup: CupSize) => void
}

export default function CupSelector({ cupSizes, selectedCup, onSelectCup }: CupSelectorProps) {
  return (
    <div className="grid grid-cols-4 gap-2">
      {cupSizes.map((cup) => (
        <Button
          key={cup.id}
          variant={selectedCup.id === cup.id ? "default" : "outline"}
          className={cn("flex flex-col h-auto py-3 px-2", selectedCup.id === cup.id ? "border-2 border-primary" : "")}
          onClick={() => onSelectCup(cup)}
        >
          <span className="text-xl mb-1">{cup.icon}</span>
          <span className="text-xs">{cup.name}</span>
          <span className="text-xs font-bold">{cup.amount}ml</span>
        </Button>
      ))}
    </div>
  )
}
```

Now, let's create a WaterTracker component that will display the user's daily water intake progress and provide feedback on their goal achievement. This component will help users stay motivated and hydrated throughout the day.

```tsx file="components/water-tracker.tsx"
"use client"

import { useState } from "react"
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Progress } from "@/components/ui/progress"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { Droplet, Home, History, Trash2 } from "lucide-react"
import CupSelector from "./cup-selector"
import WaterHistory from "./water-history"
import CelebrationAnimation from "./celebration-animation"
import WaterVisualization from "./water-visualization"
import { useToast } from "@/hooks/use-toast"
import { useLocalStorage } from "@/hooks/use-local-storage"
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog"

// Cup sizes in ml
const CUP_SIZES = [
  { id: "small", name: "Small", amount: 100, icon: "ü•§" },
  { id: "medium", name: "Medium", amount: 250, icon: "ü•õ" },
  { id: "large", name: "Large", amount: 500, icon: "üç∂" },
  { id: "bottle", name: "Bottle", amount: 750, icon: "üß¥" },
]

// Default daily goal in ml
const DEFAULT_GOAL = 2000

interface WaterEntry {
  id: number
  date: string
  time: string
  amount: number
  cupType: string
}

export default function WaterTracker() {
  const { toast } = useToast()
  const [selectedCupSize, setSelectedCupSize] = useState(CUP_SIZES[1])
  const [dailyGoal, setDailyGoal] = useLocalStorage("waterGoal", DEFAULT_GOAL)
  const [waterIntake, setWaterIntake] = useLocalStorage<WaterEntry[]>("waterIntake", [])
  const [showCelebration, setShowCelebration] = useState(false)
  const [activeTab, setActiveTab] = useState("dashboard")
  const [entryToDelete, setEntryToDelete] = useState<WaterEntry | null>(null)
  const [isDeleteDialogOpen, setIsDeleteDialogOpen] = useState(false)

  // Calculate today's intake
  const today = new Date().toISOString().split("T")[0]
  const todayIntake = waterIntake
    .filter((entry) => entry.date === today)
    .reduce((total, entry) => total + entry.amount, 0)

  const percentComplete = Math.min(Math.round((todayIntake / dailyGoal) * 100), 100)

  // Add water intake
  const addWater = (amount = selectedCupSize.amount, cupType = selectedCupSize.id) => {
    // Check if adding this amount would exceed the goal
    if (todayIntake >= dailyGoal) {
      toast({
        title: "Daily goal already reached",
        description: "You've already reached your water intake goal for today!",
      })
      return
    }

    const newEntry = {
      id: Date.now(),
      date: today,
      time: new Date().toLocaleTimeString(),
      amount: amount,
      cupType: cupType,
    }

    const newIntake = [...waterIntake, newEntry]
    setWaterIntake(newIntake)

    const newTodayIntake = todayIntake + amount

    // Check if goal reached for the first time
    if (todayIntake < dailyGoal && newTodayIntake >= dailyGoal) {
      setShowCelebration(true)
      setTimeout(() => setShowCelebration(false), 3000)
    }
  }

  // Confirm delete
  const confirmDelete = (entry: WaterEntry) => {
    setEntryToDelete(entry)
    setIsDeleteDialogOpen(true)
  }

  // Delete water intake entry
  const deleteEntry = () => {
    if (!entryToDelete) return

    const deletedEntry = { ...entryToDelete }

    // Remove the entry from waterIntake
    const updatedIntake = waterIntake.filter((entry) => entry.id !== deletedEntry.id)
    setWaterIntake(updatedIntake)

    // Close dialog
    setIsDeleteDialogOpen(false)

    // Show toast with undo option
    toast({
      title: "Entry deleted",
      description: `Removed ${deletedEntry.amount}ml from your history.`,
      action: (
        <Button variant="outline" size="sm" onClick={() => undoDelete(deletedEntry)}>
          Undo
        </Button>
      ),
    })
  }

  // Undo delete
  const undoDelete = (entry: WaterEntry) => {
    // Check if the entry already exists in waterIntake
    setWaterIntake((prev) => {
      // If the entry already exists, don't add it again
      if (prev.some((item) => item.id === entry.id)) {
        return prev
      }
      // Otherwise, add it back
      return [...prev, entry]
    })

    toast({
      title: "Entry restored",
      description: `Added ${entry.amount}ml back to your history.`,
    })
  }

  // Reset today's intake
  const resetToday = () => {
    const filteredIntake = waterIntake.filter((entry) => entry.date !== today)
    setWaterIntake(filteredIntake)
    toast({
      title: "Reset today's water intake",
      description: "Starting fresh!",
    })
  }

  // Get recent entries
  const recentEntries = waterIntake
    .filter((entry) => entry.date === today)
    .sort((a, b) => b.id - a.id)
    .slice(0, 5)

  return (
    <>
      {showCelebration && <CelebrationAnimation />}

      {/* Desktop Layout */}
      <div className="hidden md:flex h-screen">
        {/* Sidebar */}
        <div className="w-64 bg-white border-r border-gray-200 flex flex-col">
          <div className="p-4 border-b">
            <h1 className="text-xl font-bold text-black">Water Tracker</h1>
            <p className="text-sm text-gray-600">Stay hydrated, stay healthy</p>
          </div>

          <nav className="flex-1 p-4 space-y-2">
            <Button
              variant={activeTab === "dashboard" ? "default" : "ghost"}
              className={`w-full justify-start ${activeTab === "dashboard" ? "text-white" : "text-gray-800"}`}
              onClick={() => setActiveTab("dashboard")}
            >
              <Home className="mr-2 h-4 w-4" />
              Dashboard
            </Button>
            <Button
              variant={activeTab === "history" ? "default" : "ghost"}
              className={`w-full justify-start ${activeTab === "history" ? "text-white" : "text-gray-800"}`}
              onClick={() => setActiveTab("history")}
            >
              <History className="mr-2 h-4 w-4" />
              History
            </Button>
          </nav>
        </div>

        {/* Main Content */}
        <div className="flex-1 overflow-auto bg-white">
          <div className="p-6 max-w-6xl mx-auto">
            {/* Dashboard */}
            {activeTab === "dashboard" && (
              <div className="space-y-6">
                <div className="grid grid-cols-3 gap-6">
                  <Card className="col-span-2 bg-white">
                    <CardHeader className="pb-2">
                      <CardTitle>Today's Progress</CardTitle>
                      <CardDescription>
                        {percentComplete === 100
                          ? "Congratulations! You've reached your daily goal."
                          : `${percentComplete}% of your daily goal completed`}
                      </CardDescription>
                    </CardHeader>
                    <CardContent>
                      <div className="flex flex-col lg:flex-row lg:items-end gap-4">
                        <div className="mx-auto lg:mx-0">
                          <WaterVisualization
                            percentage={percentComplete}
                            currentAmount={todayIntake}
                            goalAmount={dailyGoal}
                          />
                        </div>
                        <div className="flex-1 space-y-4">
                          <div>
                            <div className="flex justify-between text-sm mb-1">
                              <span>
                                Progress: {todayIntake}ml / {dailyGoal}ml
                              </span>
                              <span>{percentComplete}%</span>
                            </div>
                            <Progress value={percentComplete} className="h-3" />
                          </div>
                          <div className="flex gap-2">
                            <Button
                              className="flex-1 py-2"
                              onClick={() => addWater()}
                              disabled={percentComplete >= 100}
                            >
                              <Droplet className="mr-1 h-4 w-4 flex-shrink-0" />
                              <span className="truncate">{percentComplete >= 100 ? "Goal Reached" : "Add Water"}</span>
                            </Button>
                            <Button variant="outline" className="flex-1 py-2" onClick={resetToday}>
                              <span className="truncate">Reset Today</span>
                            </Button>
                          </div>
                        </div>
                      </div>
                    </CardContent>
                  </Card>

                  <Card className="bg-white">
                    <CardHeader>
                      <CardTitle>Daily Goal</CardTitle>
                      <CardDescription>Your target water intake</CardDescription>
                    </CardHeader>
                    <CardContent className="space-y-4">
                      <div className="text-4xl font-bold text-center text-blue-500">{dailyGoal}ml</div>
                      <div className="grid grid-cols-2 gap-2">
                        {[1500, 2000, 2500, 3000].map((goal) => (
                          <Button
                            key={goal}
                            variant={dailyGoal === goal ? "default" : "outline"}
                            size="sm"
                            onClick={() => setDailyGoal(goal)}
                          >
                            {goal}ml
                          </Button>
                        ))}
                      </div>
                    </CardContent>
                  </Card>
                </div>

                <div className="grid grid-cols-3 gap-6">
                  <Card className="col-span-2 bg-white">
                    <CardHeader>
                      <CardTitle>Recent Activity</CardTitle>
                      <CardDescription>Your latest water intake entries</CardDescription>
                    </CardHeader>
                    <CardContent>
                      {recentEntries.length > 0 ? (
                        <div className="space-y-2">
                          {recentEntries.map((entry) => (
                            <div key={entry.id} className="flex items-center p-2 rounded-md hover:bg-gray-50">
                              <div className="text-2xl mr-3">
                                {CUP_SIZES.find((cup) => cup.id === entry.cupType)?.icon || "ü•§"}
                              </div>
                              <div className="flex-1">
                                <div className="font-medium">{entry.amount}ml of water</div>
                                <div className="text-sm text-gray-500">{entry.time}</div>
                              </div>
                              <Button
                                variant="ghost"
                                size="icon"
                                className="text-gray-400 hover:text-red-500"
                                onClick={() => confirmDelete(entry)}
                              >
                                <Trash2 className="h-4 w-4" />
                                <span className="sr-only">Delete entry</span>
                              </Button>
                            </div>
                          ))}
                        </div>
                      ) : (
                        <div className="text-center py-6 text-gray-500">
                          No water intake recorded today. Start drinking!
                        </div>
                      )}
                    </CardContent>
                  </Card>

                  <Card className="bg-white">
                    <CardHeader>
                      <CardTitle>Cup Selection</CardTitle>
                      <CardDescription>Choose your preferred cup size</CardDescription>
                    </CardHeader>
                    <CardContent>
                      <div className="grid grid-cols-2 gap-3">
                        {CUP_SIZES.map((cup) => (
                          <Button
                            key={cup.id}
                            variant={selectedCupSize.id === cup.id ? "default" : "outline"}
                            className="flex flex-col h-auto py-3"
                            onClick={() => setSelectedCupSize(cup)}
                          >
                            <span className="text-2xl mb-1">{cup.icon}</span>
                            <span className="text-sm">{cup.name}</span>
                            <span className="text-sm font-bold">{cup.amount}ml</span>
                          </Button>
                        ))}
                      </div>
                    </CardContent>
                  </Card>
                </div>
              </div>
            )}

            {/* History */}
            {activeTab === "history" && (
              <WaterHistory waterIntake={waterIntake} dailyGoal={dailyGoal} onDeleteEntry={confirmDelete} />
            )}
          </div>
        </div>
      </div>

      {/* Mobile Layout */}
      <div className="md:hidden min-h-screen p-4 bg-white">
        <h1 className="text-2xl font-bold text-center mb-4 text-black">Water Tracker</h1>

        <Tabs defaultValue="dashboard" value={activeTab} onValueChange={setActiveTab}>
          <TabsList className="grid w-full grid-cols-2">
            <TabsTrigger value="dashboard">
              <Home className="h-4 w-4 mr-2" />
              Dashboard
            </TabsTrigger>
            <TabsTrigger value="history">
              <History className="h-4 w-4 mr-2" />
              History
            </TabsTrigger>
          </TabsList>

          <TabsContent value="dashboard">
            <Card className="bg-white">
              <CardHeader>
                <CardTitle>Daily Water Intake</CardTitle>
                <CardDescription>Track your hydration throughout the day</CardDescription>
              </CardHeader>
              <CardContent className="space-y-4">
                <div className="space-y-2">
                  <div className="flex justify-between text-sm">
                    <span>
                      Progress: {todayIntake}ml / {dailyGoal}ml
                    </span>
                    <span>{percentComplete}%</span>
                  </div>
                  <Progress value={percentComplete} className="h-3" />
                </div>

                <div className="py-4">
                  <h3 className="mb-3 text-sm font-medium">Select cup size:</h3>
                  <CupSelector cupSizes={CUP_SIZES} selectedCup={selectedCupSize} onSelectCup={setSelectedCupSize} />
                </div>

                <Button className="w-full py-6 text-lg" onClick={() => addWater()} disabled={percentComplete >= 100}>
                  <Droplet className="mr-2 h-5 w-5" />
                  {percentComplete >= 100 ? "Goal Reached" : `Add Water (${selectedCupSize.amount}ml)`}
                </Button>
              </CardContent>
              <CardFooter className="flex flex-col space-y-4">
                <Button variant="outline" className="w-full" onClick={resetToday}>
                  Reset Today
                </Button>

                <div className="w-full space-y-2">
                  <h3 className="text-sm font-medium">Daily Water Goal (ml):</h3>
                  <div className="grid grid-cols-2 gap-2">
                    {[1500, 2000, 2500, 3000].map((goal) => (
                      <Button
                        key={goal}
                        variant={dailyGoal === goal ? "default" : "outline"}
                        size="sm"
                        onClick={() => setDailyGoal(goal)}
                      >
                        {goal}ml
                      </Button>
                    ))}
                  </div>
                </div>
              </CardFooter>
            </Card>
          </TabsContent>

          <TabsContent value="history">
            <WaterHistory waterIntake={waterIntake} dailyGoal={dailyGoal} onDeleteEntry={confirmDelete} />
          </TabsContent>
        </Tabs>
      </div>

      {/* Delete Confirmation Dialog */}
      <AlertDialog open={isDeleteDialogOpen} onOpenChange={setIsDeleteDialogOpen}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Delete Water Entry</AlertDialogTitle>
            <AlertDialogDescription>
              Are you sure you want to delete this entry of {entryToDelete?.amount}ml?
              {entryToDelete?.date === today && " This will also update your current daily progress."}
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel onClick={() => setIsDeleteDialogOpen(false)}>Cancel</AlertDialogCancel>
            <AlertDialogAction onClick={deleteEntry} className="bg-red-500 hover:bg-red-600">
              Delete
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  )
}
```

Next, let's create a WaterVisualization component that will visually represent the user's water intake progress. This component will provide a clear and intuitive way for users to track their daily water consumption.

```tsx file="components/water-visualization.tsx"
"use client"

import { useEffect, useRef } from "react"

interface WaterVisualizationProps {
  percentage: number
  currentAmount: number
  goalAmount: number
}

export default function WaterVisualization({ percentage, currentAmount, goalAmount }: WaterVisualizationProps) {
  const canvasRef = useRef<HTMLCanvasElement>(null)

  useEffect(() => {
    const canvas = canvasRef.current
    if (!canvas) return

    const ctx = canvas.getContext("2d")
    if (!ctx) return

    const width = canvas.width
    const height = canvas.height

    // Clear canvas
    ctx.clearRect(0, 0, width, height)

    // Adjust glass position to give more space for measurements
    const glassLeftX = width * 0.3 // Increased from 0.2 to 0.3
    const glassRightX = width * 0.8
    const glassWidth = glassRightX - glassLeftX
    const glassCenterX = glassLeftX + glassWidth / 2

    // Draw glass container
    ctx.beginPath()
    ctx.moveTo(glassLeftX, height * 0.1)
    ctx.lineTo(glassLeftX, height * 0.9)
    ctx.lineTo(glassRightX, height * 0.9)
    ctx.lineTo(glassRightX, height * 0.1)
    ctx.strokeStyle = "#94a3b8"
    ctx.lineWidth = 3
    ctx.stroke()

    // Calculate water height based on percentage
    const waterHeight = height * 0.8 * (percentage / 100)
    const waterY = height * 0.9 - waterHeight

    // Draw water
    const waterGradient = ctx.createLinearGradient(0, waterY, 0, height * 0.9)
    waterGradient.addColorStop(0, "rgba(59, 130, 246, 0.8)")
    waterGradient.addColorStop(1, "rgba(59, 130, 246, 0.5)")

    ctx.fillStyle = waterGradient
    ctx.fillRect(glassLeftX, waterY, glassWidth, waterHeight)

    // Draw water surface with wave effect
    ctx.beginPath()
    ctx.moveTo(glassLeftX, waterY)

    const waveHeight = 5
    const segments = 6
    const segmentWidth = glassWidth / segments

    for (let i = 0; i <= segments; i++) {
      const x = glassLeftX + i * segmentWidth
      const y = waterY + (i % 2 === 0 ? -waveHeight : waveHeight)
      ctx.lineTo(x, y)
    }

    ctx.lineTo(glassRightX, waterY)
    ctx.lineTo(glassRightX, height * 0.9)
    ctx.lineTo(glassLeftX, height * 0.9)
    ctx.closePath()

    ctx.fillStyle = waterGradient
    ctx.fill()

    // Draw measurement lines with correct values
    for (let i = 1; i <= 4; i++) {
      const y = height * 0.9 - height * 0.8 * (i / 4)
      const measurementValue = Math.round(goalAmount * (i / 4))

      ctx.beginPath()
      ctx.moveTo(glassLeftX - 10, y) // Increased space for measurement line
      ctx.lineTo(glassLeftX, y)
      ctx.strokeStyle = "#94a3b8"
      ctx.lineWidth = 2
      ctx.stroke()

      // Draw measurement text with more space
      ctx.font = "12px sans-serif"
      ctx.fillStyle = "#64748b"
      ctx.textAlign = "right"
      ctx.fillText(`${measurementValue}ml`, glassLeftX - 15, y + 4) // Increased space for text
    }
  }, [percentage, currentAmount, goalAmount])

  return (
    <div className="relative">
      <canvas ref={canvasRef} width={220} height={250} className="mx-auto" />
      <div className="absolute inset-0 flex items-center justify-center">
        <div
          className="text-center bg-white bg-opacity-70 px-4 py-2 rounded-lg"
          style={{
            transform: "translateX(10%)", // Shift the percentage display to center it within the glass
            maxWidth: "90px",
          }}
        >
          <div className={`font-bold text-blue-700 ${percentage === 100 ? "text-2xl" : "text-3xl"}`}>{percentage}%</div>
          <div className="text-sm text-blue-700">{currentAmount}ml</div>
        </div>
      </div>
    </div>
  )
}
```

Now, let's create a WaterHistory component that will display the user's water intake history and achievements. This component will allow users to track their progress over time and celebrate their milestones.

```tsx file="components/water-history.tsx"
"use client"

import { useMemo } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Droplet, Trash2 } from "lucide-react"
import { Progress } from "@/components/ui/progress"
import { Button } from "@/components/ui/button"

interface WaterEntry {
  id: number
  date: string
  time: string
  amount: number
  cupType: string
}

interface WaterHistoryProps {
  waterIntake: WaterEntry[]
  dailyGoal: number
  onDeleteEntry: (entry: WaterEntry) => void
}

export default function WaterHistory({ waterIntake, dailyGoal, onDeleteEntry }: WaterHistoryProps) {
  // Group entries by date
  const groupedByDate = useMemo(() => {
    const grouped = waterIntake.reduce(
      (acc, entry) => {
        if (!acc[entry.date]) {
          acc[entry.date] = {
            entries: [],
            total: 0,
          }
        }
        acc[entry.date].entries.push(entry)
        acc[entry.date].total += entry.amount
        return acc
      },
      {} as Record<string, { entries: WaterEntry[]; total: number }>,
    )

    // Sort dates in descending order
    return Object.entries(grouped)
      .sort(([dateA], [dateB]) => new Date(dateB).getTime() - new Date(dateA).getTime())
      .map(([date, data]) => ({
        date,
        entries: data.entries.sort((a, b) => b.id - a.id), // Sort entries by time (newest first)
        total: data.total,
        percentComplete: Math.min(Math.round((data.total / dailyGoal) * 100), 100),
      }))
  }, [waterIntake, dailyGoal])

  // Format date for display
  const formatDate = (dateString: string) => {
    const date = new Date(dateString)
    return date.toLocaleDateString("en-US", {
      weekday: "short",
      month: "short",
      day: "numeric",
    })
  }

  if (groupedByDate.length === 0) {
    return (
      <Card className="bg-white">
        <CardHeader>
          <CardTitle>Water History</CardTitle>
          <CardDescription>Your water intake history will appear here</CardDescription>
        </CardHeader>
        <CardContent>
          <div className="text-center py-8 text-gray-500">No water intake recorded yet. Start drinking!</div>
        </CardContent>
      </Card>
    )
  }

  return (
    <Card className="bg-white">
      <CardHeader>
        <CardTitle>Water History</CardTitle>
        <CardDescription>Your recent water intake</CardDescription>
      </CardHeader>
      <CardContent>
        <div className="space-y-6">
          {groupedByDate.map(({ date, entries, total, percentComplete }) => (
            <div key={date} className="border rounded-lg overflow-hidden">
              <div className="bg-gray-50 p-4 border-b">
                <div className="flex justify-between items-center">
                  <h3 className="font-medium">{formatDate(date)}</h3>
                  <div className="text-sm">
                    <span className="font-medium">{total}ml</span>
                    <span className="text-gray-500"> / {dailyGoal}ml</span>
                  </div>
                </div>
                <div className="mt-2">
                  <Progress value={percentComplete} className="h-2" />
                  <div className="flex justify-between text-xs text-gray-500 mt-1">
                    <span>{percentComplete}% of daily goal</span>
                    <span>{entries.length} entries</span>
                  </div>
                </div>
              </div>

              <div className="divide-y">
                {entries.map((entry) => (
                  <div key={entry.id} className="flex items-center p-3 hover:bg-gray-50">
                    <div className="h-8 w-8 rounded-full bg-blue-100 flex items-center justify-center mr-3">
                      <Droplet className="h-4 w-4 text-blue-500" />
                    </div>
                    <div className="flex-1">
                      <div className="font-medium">{entry.amount}ml of water</div>
                      <div className="text-sm text-gray-500">{entry.time}</div>
                    </div>
                    <Button
                      variant="ghost"
                      size="icon"
                      className="text-gray-400 hover:text-red-500"
                      onClick={() => onDeleteEntry(entry)}
                    >
                      <Trash2 className="h-4 w-4" />
                      <span className="sr-only">Delete entry</span>
                    </Button>
                  </div>
                ))}
              </div>
            </div>
          ))}
        </div>
      </CardContent>
    </Card>
  )
}
```

Next, let's create a Toaster component that will display toast notifications for user actions and alerts. This component will provide feedback to users and enhance the user experience.

```tsx file="components/toaster.tsx"
"use client"

import { Toast, ToastClose, ToastDescription, ToastProvider, ToastTitle, ToastViewport } from "@/components/ui/toast"
import { useToast } from "@/hooks/use-toast"

export function Toaster() {
  const { toasts } = useToast()

  return (
    <ToastProvider>
      {toasts.map(({ id, title, description, action, ...props }) => (
        <Toast key={id} {...props}>
          <div className="grid gap-1">
            {title && <ToastTitle>{title}</ToastTitle>}
            {description && <ToastDescription>{description}</ToastDescription>}
          </div>
          {action}
          <ToastClose />
        </Toast>
      ))}
      <ToastViewport />
    </ToastProvider>
  )
}
```

Now, let's create a custom hook called useToast that will handle toast notifications in our application. This hook will simplify the process of displaying notifications and make it easy to provide feedback to users.

```tsx file="hooks/use-toast.ts"
"use client"

// Inspired by react-hot-toast library
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }
```

Next, let's create a custom hook called useLocalStorage that will handle reading and writing data to local storage. This hook will allow us to persist user data across sessions and provide a seamless experience.

```tsx file="hooks/use-local-storage.ts"
"use client"

import { useState, useEffect } from "react"

export function useLocalStorage<T>(key: string, initialValue: T) {
  // State to store our value
  // Pass initial state function to useState so logic is only executed once
  const [storedValue, setStoredValue] = useState<T>(() => {
    if (typeof window === "undefined") {
      return initialValue
    }

    try {
      // Get from local storage by key
      const item = window.localStorage.getItem(key)
      // Parse stored json or if none return initialValue
      return item ? JSON.parse(item) : initialValue
    } catch (error) {
      console.log(error)
      return initialValue
    }
  })

  // Return a wrapped version of useState's setter function that
  // persists the new value to localStorage.
  const setValue = (value: T | ((val: T) => T)) => {
    try {
      // Allow value to be a function so we have same API as useState
      const valueToStore = value instanceof Function ? value(storedValue) : value

      // Save state
      setStoredValue(valueToStore)

      // Save to local storage
      if (typeof window !== "undefined") {
        window.localStorage.setItem(key, JSON.stringify(valueToStore))
      }
    } catch (error) {
      console.log(error)
    }
  }

  // Sync with localStorage when the key changes
  useEffect(() => {
    if (typeof window === "undefined") {
      return
    }

    const handleStorageChange = (e: StorageEvent) => {
      if (e.key === key && e.newValue) {
        try {
          setStoredValue(JSON.parse(e.newValue))
        } catch (error) {
          console.log(error)
        }
      }
    }

    // Listen for changes to this localStorage key in other tabs/windows
    window.addEventListener("storage", handleStorageChange)
    return () => window.removeEventListener("storage", handleStorageChange)
  }, [key])

  return [storedValue, setValue] as const
}
```

Now, let's create a custom hook called useMobile that will detect the user's device type and screen size. This hook will help us optimize the layout and user experience for different devices.

```tsx file="hooks/use-mobile.tsx"
import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}
```

Next, let's update the Layout component to include the new components we've created. This component will serve as the main layout for our application and provide a consistent structure for our pages.

```tsx file="app/layout.tsx"
import type React from "react"
import { ThemeProvider } from "@/components/theme-provider"
import "./globals.css"
import type { Metadata } from "next"
import { Toaster } from "@/components/toaster"

export const metadata: Metadata = {
  title: "Water Intake Tracker",
  description: "Track your daily water intake and stay hydrated",
  icons: {
    icon: "/icon.png",
  },
  generator: "v0.dev",
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en" className="light">
      <body className="bg-background text-foreground">
        <ThemeProvider attribute="class" defaultTheme="light" enableSystem={false} disableTransitionOnChange>
          {children}
          <Toaster />
        </ThemeProvider>
      </body>
    </html>
  )
}

import "./globals.css"



import './globals.css'
```

Finally, let's update the Page component to include the new components and hooks we've created. This component will serve as the main page template for our application and help us organize our content effectively.`;

```tsx file="app/page.tsx"
import WaterTracker from "@/components/water-tracker"

export default function Home() {
  return (
    <main className="min-h-screen bg-gradient-to-br from-blue-50 to-white">
      <WaterTracker />
    </main>
  )
}
```

