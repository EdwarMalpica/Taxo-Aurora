First, let's create a types file to define the types and interfaces that we'll use in our project. This file will help us ensure type safety and consistency in our code.

```tsx file="types.tsx"
export type TaskStatus = "pending" | "completed"

export interface Task {
  id: string
  title: string
  assignee: string
  dueDate: string
  status: TaskStatus
  recurring: string
  description?: string
  createdAt?: string
}
```

Next, let's create a utility file to handle date-related functions and constants that we'll use throughout the project. This file will help us manage dates, times, and time zones effectively.

```tsx file="lib/date-utils.ts"
export function formatDate(date: Date): string {
  // Format date as "Month Day, Year" (e.g., "March 25, 2023")
  return date.toLocaleDateString("en-US", {
    month: "long",
    day: "numeric",
    year: "numeric",
  })
}
```

Now, let's create a utility file to store common functions and constants that we'll use throughout the project. This file will help us keep our code organized and maintainable.

```tsx file="lib/utils.ts"
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
```

Next, let's create a type file to define the Task type that we'll use to represent tasks in our application. This file will help us ensure type safety and consistency when working with tasks.

```tsx file="types/task.ts"
export type TaskStatus = "done" | "pending"

export interface Task {
  id: string
  title: string
  description?: string
  assignee: string
  status: TaskStatus
  createdAt: Date
  updatedAt?: Date
}
```

Now, let's create a ThemeProvider component that will handle the theme context for our application. This component will allow us to switch between light and dark themes easily.

```tsx file="components/theme-provider.tsx"
"use client"

import type * as React from "react"
import { createContext, useContext, useEffect, useState } from "react"

type Theme = "dark" | "light" | "system"

type ThemeProviderProps = {
  children: React.ReactNode
  defaultTheme?: Theme
  storageKey?: string
}

type ThemeProviderState = {
  theme: Theme
  setTheme: (theme: Theme) => void
}

const initialState: ThemeProviderState = {
  theme: "system",
  setTheme: () => null,
}

const ThemeProviderContext = createContext<ThemeProviderState>(initialState)

export function ThemeProvider({
  children,
  defaultTheme = "system",
  storageKey = "ui-theme",
  ...props
}: ThemeProviderProps) {
  const [theme, setTheme] = useState<Theme>(defaultTheme)

  useEffect(() => {
    const root = window.document.documentElement
    root.classList.remove("light", "dark")

    if (theme === "system") {
      const systemTheme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light"
      root.classList.add(systemTheme)
      return
    }

    root.classList.add(theme)
  }, [theme])

  const value = {
    theme,
    setTheme: (theme: Theme) => {
      localStorage.setItem(storageKey, theme)
      setTheme(theme)
    },
  }

  return (
    <ThemeProviderContext.Provider {...props} value={value}>
      {children}
    </ThemeProviderContext.Provider>
  )
}

export const useTheme = () => {
  const context = useContext(ThemeProviderContext)

  if (context === undefined) throw new Error("useTheme must be used within a ThemeProvider")

  return context
}
```

Next, let's create a RecentTasks component that will display a list of recently completed tasks. This component will help users track their progress and stay motivated.

```tsx file="components/recent-tasks.tsx"
"use client"

import { useState, useEffect, useRef } from "react"
import { CheckCircle2, Clock, Trash2, Filter, ArrowUp, ArrowDown, ArrowUpDown, Edit } from "lucide-react"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { Checkbox } from "@/components/ui/checkbox"
import { useAlertDialog } from "@/contexts/alert-dialog-context"
import { toast } from "sonner"
import { useTaskContext } from "@/contexts/task-context"
import { Pagination, PaginationContent, PaginationItem } from "@/components/ui/pagination"
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuCheckboxItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu"
import { TaskModal } from "./task-modal"
import type { Task } from "@/types"

interface RecentTasksProps {
  searchQuery?: string
}

type SortConfig = {
  key: string
  direction: "asc" | "desc" | null
}

export function RecentTasks({ searchQuery = "" }: RecentTasksProps) {
  const { tasks, deleteTask, updateTask, restoreTask } = useTaskContext()
  const { showDialog } = useAlertDialog()
  const tableRef = useRef<HTMLDivElement>(null)

  const [currentPage, setCurrentPage] = useState(1)
  const tasksPerPage = 5

  const [statusFilter, setStatusFilter] = useState<string[]>([])
  const [assigneeFilter, setAssigneeFilter] = useState<string[]>([])
  const [recurringFilter, setRecurringFilter] = useState<string[]>([])

  const [sortConfig, setSortConfig] = useState<SortConfig>({
    key: "",
    direction: null,
  })

  const [isEditModalOpen, setIsEditModalOpen] = useState(false)
  const [selectedTask, setSelectedTask] = useState<Task | null>(null)

  const uniqueAssignees = [...new Set(tasks.map((task) => task.assignee))]
  const uniqueRecurring = [...new Set(tasks.map((task) => task.recurring))]

  const sortedTasks = [...tasks].sort((a, b) => {
    if (!sortConfig.key || sortConfig.direction === null) return 0

    const aValue = a[sortConfig.key as keyof typeof a]
    const bValue = b[sortConfig.key as keyof typeof b]

    if (sortConfig.key === "dueDate") {
      return sortConfig.direction === "asc"
        ? new Date(aValue as string).getTime() - new Date(bValue as string).getTime()
        : new Date(bValue as string).getTime() - new Date(aValue as string).getTime()
    }

    if (typeof aValue === "string" && typeof bValue === "string") {
      return sortConfig.direction === "asc" ? aValue.localeCompare(bValue) : bValue.localeCompare(aValue)
    }

    return 0
  })

  const requestSort = (key: string) => {
    let direction: "asc" | "desc" | null = "asc"

    if (sortConfig.key === key) {
      if (sortConfig.direction === "asc") {
        direction = "desc"
      } else if (sortConfig.direction === "desc") {
        direction = null
      }
    }

    setSortConfig({ key, direction })
  }

  const getSortDirectionIcon = (key: string) => {
    if (sortConfig.key !== key) {
      return <ArrowUpDown className="h-4 w-4 ml-1" />
    }

    if (sortConfig.direction === "asc") {
      return <ArrowUp className="h-4 w-4 ml-1" />
    }

    if (sortConfig.direction === "desc") {
      return <ArrowDown className="h-4 w-4 ml-1" />
    }

    return <ArrowUpDown className="h-4 w-4 ml-1" />
  }

  const filteredTasks = sortedTasks.filter((task) => {
    const matchesSearch =
      task.title.toLowerCase().includes(searchQuery.toLowerCase()) ||
      task.assignee.toLowerCase().includes(searchQuery.toLowerCase())

    const matchesStatus = statusFilter.length === 0 || statusFilter.includes(task.status)

    const matchesAssignee = assigneeFilter.length === 0 || assigneeFilter.includes(task.assignee)

    const matchesRecurring = recurringFilter.length === 0 || recurringFilter.includes(task.recurring)

    return matchesSearch && matchesStatus && matchesAssignee && matchesRecurring
  })

  useEffect(() => {
    setCurrentPage(1)
  }, [searchQuery, statusFilter, assigneeFilter, recurringFilter])

  const totalPages = Math.ceil(filteredTasks.length / tasksPerPage)
  const paginatedTasks = filteredTasks.slice((currentPage - 1) * tasksPerPage, currentPage * tasksPerPage)

  const handlePageChange = (newPage: number) => {
    const scrollPosition = window.scrollY

    setCurrentPage(newPage)

    setTimeout(() => {
      window.scrollTo(0, scrollPosition)
    }, 0)
  }

  const handleDeleteTask = (taskId: string) => {
    let undo = false
    const taskIndex = tasks.findIndex((task) => task.id === taskId)
    if (taskIndex === -1) return

    deleteTask(taskId)

    toast("Task Deleted", {
      description: "The task has been deleted",
      action: {
        label: "Undo",
        onClick: () => {
          undo = true
          restoreTask()
        },
      },
      duration: 5000,
      onAutoClose: () => {
        if (!undo) {
        }
      },
    })
  }

  const toggleTaskStatus = (id: string) => {
    const task = tasks.find((task) => task.id === id)
    if (!task) return

    updateTask(id, {
      status: task.status === "completed" ? "pending" : "completed",
    })
  }

  const handleEditTask = (task: Task) => {
    setSelectedTask(task)
    setIsEditModalOpen(true)
  }

  return (
    <div className="w-full min-h-[400px]" ref={tableRef}>
      <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-4 gap-2">
        <div className="flex flex-wrap gap-2">
          {/* Status Filter */}
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button variant="outline" size="sm" className="h-8 gap-1">
                <Filter className="h-3.5 w-3.5" />
                Status
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="start" className="w-48">
              <DropdownMenuCheckboxItem
                checked={statusFilter.includes("completed")}
                onCheckedChange={(checked) => {
                  setStatusFilter((prev) => (checked ? [...prev, "completed"] : prev.filter((s) => s !== "completed")))
                }}
              >
                Completed
              </DropdownMenuCheckboxItem>
              <DropdownMenuCheckboxItem
                checked={statusFilter.includes("pending")}
                onCheckedChange={(checked) => {
                  setStatusFilter((prev) => (checked ? [...prev, "pending"] : prev.filter((s) => s !== "pending")))
                }}
              >
                Pending
              </DropdownMenuCheckboxItem>
            </DropdownMenuContent>
          </DropdownMenu>

          {/* Assignee Filter */}
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button variant="outline" size="sm" className="h-8 gap-1">
                <Filter className="h-3.5 w-3.5" />
                Assignee
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="start" className="w-48">
              {uniqueAssignees.map((assignee) => (
                <DropdownMenuCheckboxItem
                  key={assignee}
                  checked={assigneeFilter.includes(assignee)}
                  onCheckedChange={(checked) => {
                    setAssigneeFilter((prev) => (checked ? [...prev, assignee] : prev.filter((a) => a !== assignee)))
                  }}
                >
                  {assignee}
                </DropdownMenuCheckboxItem>
              ))}
            </DropdownMenuContent>
          </DropdownMenu>

          {/* Recurring Filter */}
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button variant="outline" size="sm" className="h-8 gap-1">
                <Filter className="h-3.5 w-3.5" />
                Frequency
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="start" className="w-48">
              {uniqueRecurring.map((recurring) => (
                <DropdownMenuCheckboxItem
                  key={recurring}
                  checked={recurringFilter.includes(recurring)}
                  onCheckedChange={(checked) => {
                    setRecurringFilter((prev) => (checked ? [...prev, recurring] : prev.filter((r) => r !== recurring)))
                  }}
                >
                  {recurring}
                </DropdownMenuCheckboxItem>
              ))}
            </DropdownMenuContent>
          </DropdownMenu>

          {/* Clear Filters */}
          {(statusFilter.length > 0 || assigneeFilter.length > 0 || recurringFilter.length > 0) && (
            <Button
              variant="ghost"
              size="sm"
              className="h-8"
              onClick={() => {
                setStatusFilter([])
                setAssigneeFilter([])
                setRecurringFilter([])
              }}
            >
              Clear Filters
            </Button>
          )}
        </div>
      </div>

      <div className="w-full overflow-auto min-h-[300px]">
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead className="w-[50px]"></TableHead>
              <TableHead className="cursor-pointer" onClick={() => requestSort("title")}>
                <div className="flex items-center">Task {getSortDirectionIcon("title")}</div>
              </TableHead>
              <TableHead className="cursor-pointer" onClick={() => requestSort("assignee")}>
                <div className="flex items-center">Assignee {getSortDirectionIcon("assignee")}</div>
              </TableHead>
              <TableHead className="cursor-pointer" onClick={() => requestSort("dueDate")}>
                <div className="flex items-center">Due Date {getSortDirectionIcon("dueDate")}</div>
              </TableHead>
              <TableHead className="cursor-pointer" onClick={() => requestSort("recurring")}>
                <div className="flex items-center">Recurring {getSortDirectionIcon("recurring")}</div>
              </TableHead>
              <TableHead className="cursor-pointer" onClick={() => requestSort("status")}>
                <div className="flex items-center">Status {getSortDirectionIcon("status")}</div>
              </TableHead>
              <TableHead className="text-right">Actions</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {paginatedTasks.length > 0 ? (
              paginatedTasks.map((task) => (
                <TableRow key={task.id}>
                  <TableCell>
                    <Checkbox checked={task.status === "completed"} onCheckedChange={() => toggleTaskStatus(task.id)} />
                  </TableCell>
                  <TableCell className="font-medium">{task.title}</TableCell>
                  <TableCell>{task.assignee}</TableCell>
                  <TableCell>{new Date(task.dueDate).toLocaleDateString("en-GB")}</TableCell>
                  <TableCell>
                    <Badge variant="outline" className="capitalize">
                      {task.recurring}
                    </Badge>
                  </TableCell>
                  <TableCell>
                    <Badge
                      variant={task.status === "completed" ? "success" : "secondary"}
                      className="flex w-fit items-center gap-1"
                    >
                      {task.status === "completed" ? (
                        <CheckCircle2 className="h-3 w-3" />
                      ) : (
                        <Clock className="h-3 w-3" />
                      )}
                      <span className="capitalize">{task.status}</span>
                    </Badge>
                  </TableCell>
                  <TableCell className="text-right">
                    <div className="flex justify-end gap-2">
                      <Edit
                        className="h-4 w-4 cursor-pointer hover:opacity-50 delay-200 ease-in-out"
                        onClick={() => handleEditTask(task)}
                      />
                      <Trash2
                        className="h-4 w-4 cursor-pointer hover:opacity-50 delay-200 ease-in-out"
                        onClick={() =>
                          showDialog({
                            title: "Delete Task?",
                            description: "Are you sure you want to delete the task?",
                            onConfirm: () => {
                              handleDeleteTask(task.id)
                            },
                          })
                        }
                      />
                    </div>
                  </TableCell>
                </TableRow>
              ))
            ) : (
              <TableRow>
                <TableCell colSpan={7} className="text-center text-gray-500 py-4">
                  {searchQuery || statusFilter.length > 0 || assigneeFilter.length > 0 || recurringFilter.length > 0
                    ? "No tasks match your filters"
                    : "No tasks available"}
                </TableCell>
              </TableRow>
            )}
          </TableBody>
        </Table>
      </div>

      {/* Pagination Controls */}
      {totalPages > 1 && (
        <Pagination className="mt-4">
          <PaginationContent>
            <PaginationItem>
              <Button
                variant="outline"
                size="icon"
                onClick={() => handlePageChange(Math.max(currentPage - 1, 1))}
                disabled={currentPage === 1}
                className={currentPage === 1 ? "pointer-events-none opacity-50" : "cursor-pointer"}
              >
                <span className="sr-only">Go to previous page</span>
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  width="24"
                  height="24"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  strokeWidth="2"
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  className="h-4 w-4"
                >
                  <path d="m15 18-6-6 6-6"></path>
                </svg>
              </Button>
            </PaginationItem>

            {Array.from({ length: totalPages }, (_, i) => (
              <PaginationItem key={i} className="cursor-pointer">
                <Button
                  variant={i + 1 === currentPage ? "default" : "outline"}
                  size="icon"
                  onClick={() => handlePageChange(i + 1)}
                  className="h-8 w-8"
                >
                  {i + 1}
                </Button>
              </PaginationItem>
            ))}

            <PaginationItem>
              <Button
                variant="outline"
                size="icon"
                onClick={() => handlePageChange(Math.min(currentPage + 1, totalPages))}
                disabled={currentPage === totalPages}
                className={currentPage === totalPages ? "pointer-events-none opacity-50" : "cursor-pointer"}
              >
                <span className="sr-only">Go to next page</span>
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  width="24"
                  height="24"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  strokeWidth="2"
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  className="h-4 w-4"
                >
                  <path d="m9 18 6-6-6-6"></path>
                </svg>
              </Button>
            </PaginationItem>
          </PaginationContent>
        </Pagination>
      )}
      {selectedTask && (
        <TaskModal open={isEditModalOpen} onOpenChange={setIsEditModalOpen} task={selectedTask} mode="edit" />
      )}
    </div>
  )
}
```

Now, let's create a FamilyProgress component that will display the progress of family members in completing tasks. This component will provide a visual overview of family achievements and encourage collaboration.

```tsx file="components/family-progress.tsx"
"use client"

import { useEffect, useState } from "react"
import { PieChart, Pie, Cell, ResponsiveContainer, Legend, Tooltip } from "recharts"
import { useTaskContext } from "@/contexts/task-context"

const COLORS = ["#8884d8", "#82ca9d", "#ffc658", "#ff8042", "#0088fe", "#00C49F"]

const CustomTooltip = ({ active, payload }: any) => {
  if (!active || !payload || payload.length === 0) return null

  return (
    <div className="bg-background border border-border rounded-md p-2 shadow-md">
      <p className="font-semibold">{payload[0].name}</p>
      <p className="text-sm">
        Completed Tasks: <span className="font-medium">{payload[0].value}</span>
      </p>
    </div>
  )
}

export function FamilyProgress() {
  const { tasks } = useTaskContext()
  const [isMounted, setIsMounted] = useState(false)

  useEffect(() => {
    setIsMounted(true)
  }, [])

  const taskCounts = tasks.reduce((acc: Record<string, number>, task) => {
    if (task.status === "completed") {
      acc[task.assignee] = (acc[task.assignee] || 0) + 1
    }
    return acc
  }, {})

  const data = Object.keys(taskCounts)
    .filter((name) => taskCounts[name] > 0)
    .map((name, index) => ({
      name,
      value: taskCounts[name],
      color: COLORS[index % COLORS.length],
    }))

  if (data.length === 0) {
    return <div className="flex justify-center items-center h-[300px]">No completed tasks</div>
  }

  return (
    <div className="relative h-[300px]">
      <ResponsiveContainer width="100%" height="100%">
        <PieChart>
          <Pie
            data={data}
            cx="50%"
            cy="50%"
            innerRadius={60}
            outerRadius={80}
            paddingAngle={5}
            dataKey="value"
            animationBegin={0}
            animationDuration={1000}
            animationEasing="ease-out"
            isAnimationActive={isMounted}
          >
            {data.map((entry, index) => (
              <Cell key={`cell-${index}`} fill={entry.color} />
            ))}
          </Pie>
          <Tooltip content={<CustomTooltip />} />
          <Legend />
        </PieChart>
      </ResponsiveContainer>
    </div>
  )
}
```

Next, let's create a GlobalAlertDialog component that will display global alert messages for important notifications. This component will provide a consistent way to show alerts and messages to users.

```tsx file="components/global-alert-dialog.tsx"
"use client"
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog"
import { useAlertDialog } from "@/contexts/alert-dialog-context"

export function GlobalAlertDialog() {
  const { isOpen, hideDialog, options } = useAlertDialog()

  if (!options) return null

  return (
    <AlertDialog open={isOpen} onOpenChange={hideDialog}>
      <AlertDialogContent className="w-5/6">
        <AlertDialogHeader>
          <AlertDialogTitle>{options.title}</AlertDialogTitle>
          <AlertDialogDescription>{options.description}</AlertDialogDescription>
        </AlertDialogHeader>
        <AlertDialogFooter>
          <AlertDialogCancel onClick={hideDialog}>Cancel</AlertDialogCancel>
          <AlertDialogAction
            onClick={() => {
              options.onConfirm()
              hideDialog()
            }}
          >
            Yes
          </AlertDialogAction>
        </AlertDialogFooter>
      </AlertDialogContent>
    </AlertDialog>
  )
}
```

Now, let's create a TaskModal component that will allow users to view and edit task details. This component will provide a modal interface for managing task information.

```tsx file="components/task-modal.tsx"
"use client"
import { useState, useEffect } from "react"
import { toast } from "sonner"
import { CalendarIcon } from "lucide-react"
import { useTaskContext } from "@/contexts/task-context"
import { formatDate } from "@/lib/date-utils"
import { cn } from "@/lib/utils"
import { z } from "zod"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"

import { Button } from "@/components/ui/button"
import { Calendar } from "@/components/ui/calendar"
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover"
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog"
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import { Textarea } from "@/components/ui/textarea"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"

interface TaskModalProps {
  open: boolean
  onOpenChange: (open: boolean) => void
  task?: {
    id: string
    title: string
    assignee: string
    dueDate: string
    status: "pending" | "completed"
    recurring: string
    description?: string
  }
  mode: "create" | "edit"
}

const formSchema = z.object({
  title: z.string().min(1, "Title is required"),
  description: z.string().optional(),
  assignee: z.string().min(1, "Assignee is required"),
  dueDate: z.date().optional(),
  recurring: z.string().min(1, "Frequency is required"),
})

type FormValues = z.infer<typeof formSchema>

export function TaskModal({ open, onOpenChange, task, mode }: TaskModalProps) {
  const { addTask, updateTask } = useTaskContext()
  const [isCalendarOpen, setIsCalendarOpen] = useState(false)

  const form = useForm<FormValues>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      title: "",
      description: "",
      assignee: "",
      recurring: "",
      dueDate: new Date(),
    },
  })

  // Cargar datos de la tarea si estamos en modo edición
  useEffect(() => {
    if (open && mode === "edit" && task) {
      form.setValue("title", task.title)
      form.setValue("description", task.description || "")
      form.setValue("assignee", task.assignee)
      form.setValue("recurring", task.recurring)
      form.setValue("dueDate", new Date(task.dueDate))
    } else if (open && mode === "create") {
      form.setValue("dueDate", new Date())
    }
  }, [open, form, task, mode])

  // Limpiar el formulario al cerrar
  useEffect(() => {
    if (!open) {
      setTimeout(() => {
        form.reset({
          title: "",
          description: "",
          assignee: "",
          recurring: "",
          dueDate: undefined,
        })
      }, 300)
    }
  }, [open, form])

  const onSubmit = (values: FormValues) => {
    const dueDate = values.dueDate || new Date()

    if (mode === "create") {
      const newTask = {
        id: crypto.randomUUID(),
        title: values.title,
        assignee: values.assignee,
        status: "pending" as const,
        dueDate: dueDate.toISOString().split("T")[0],
        createdAt: new Date(),
        recurring: values.recurring,
        description: values.description,
      }

      addTask(newTask)
      toast.success("Task Created", {
        description: "The task was created successfully",
      })
    } else if (mode === "edit" && task) {
      updateTask(task.id, {
        title: values.title,
        assignee: values.assignee,
        dueDate: dueDate.toISOString().split("T")[0],
        recurring: values.recurring,
        description: values.description,
      })
      toast.success("Task Updated", {
        description: "The task was updated successfully",
      })
    }

    onOpenChange(false)
  }

  const title = mode === "create" ? "Create New Task" : "Edit Task"
  const description = mode === "create" ? "Add a new task for your family members" : "Edit task details"
  const submitButtonText = mode === "create" ? "Create Task" : "Save Changes"

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-[600px] max-w-[calc(100%-2rem)] mx-auto my-4 rounded-lg max-h-[calc(100vh-2rem)] overflow-y-auto">
        <DialogHeader>
          <DialogTitle>{title}</DialogTitle>
          <DialogDescription>{description}</DialogDescription>
        </DialogHeader>

        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4 py-4">
            <FormField
              control={form.control}
              name="title"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Task Title</FormLabel>
                  <FormControl>
                    <Input placeholder="Enter task title" {...field} />
                  </FormControl>
                  <div className="h-5">
                    <FormMessage />
                  </div>
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="description"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Description</FormLabel>
                  <FormControl>
                    <Textarea placeholder="Enter task description" className="min-h-[100px]" {...field} />
                  </FormControl>
                  <div className="h-5">
                    <FormMessage />
                  </div>
                </FormItem>
              )}
            />

            <div className="grid grid-cols-1 gap-4 sm:grid-cols-2">
              <FormField
                control={form.control}
                name="assignee"
                render={({ field }) => (
                  <FormItem className="flex flex-col">
                    <FormLabel>Assign To</FormLabel>
                    <Select onValueChange={field.onChange} value={field.value}>
                      <FormControl>
                        <SelectTrigger className="h-10">
                          <SelectValue placeholder="Select family member" />
                        </SelectTrigger>
                      </FormControl>
                      <SelectContent>
                        <SelectItem value="Mom">Mom</SelectItem>
                        <SelectItem value="Dad">Dad</SelectItem>
                        <SelectItem value="Emma">Emma</SelectItem>
                        <SelectItem value="Jack">Jack</SelectItem>
                      </SelectContent>
                    </Select>
                    <div className="h-5">
                      <FormMessage />
                    </div>
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="dueDate"
                render={({ field }) => (
                  <FormItem className="flex flex-col">
                    <FormLabel>Due Date</FormLabel>
                    <Popover open={isCalendarOpen} onOpenChange={setIsCalendarOpen}>
                      <PopoverTrigger asChild>
                        <FormControl>
                          <Button
                            variant={"outline"}
                            className={cn(
                              "w-full justify-start text-left font-normal h-10",
                              !field.value && "text-muted-foreground",
                            )}
                          >
                            <CalendarIcon className="mr-2 h-4 w-4" />
                            {field.value ? formatDate(field.value) : <span>Pick a date</span>}
                          </Button>
                        </FormControl>
                      </PopoverTrigger>
                      <PopoverContent className="w-auto p-0">
                        <Calendar
                          mode="single"
                          selected={field.value || undefined}
                          onSelect={(date) => {
                            field.onChange(date)
                            setIsCalendarOpen(false)
                          }}
                          initialFocus
                        />
                      </PopoverContent>
                    </Popover>
                    <div className="h-5">
                      <FormMessage />
                    </div>
                  </FormItem>
                )}
              />
            </div>

            <FormField
              control={form.control}
              name="recurring"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Recurring</FormLabel>
                  <Select onValueChange={field.onChange} value={field.value}>
                    <FormControl>
                      <SelectTrigger className="h-10">
                        <SelectValue placeholder="Select frequency" />
                      </SelectTrigger>
                    </FormControl>
                    <SelectContent>
                      <SelectItem value="none">None</SelectItem>
                      <SelectItem value="daily">Daily</SelectItem>
                      <SelectItem value="weekly">Weekly</SelectItem>
                      <SelectItem value="biweekly">Bi-weekly</SelectItem>
                      <SelectItem value="monthly">Monthly</SelectItem>
                    </SelectContent>
                  </Select>
                  <div className="h-5">
                    <FormMessage />
                  </div>
                </FormItem>
              )}
            />

            <DialogFooter className="flex flex-col sm:flex-row gap-2 pt-4">
              <Button
                variant="outline"
                type="button"
                onClick={() => onOpenChange(false)}
                className="sm:order-1 order-2"
              >
                Cancel
              </Button>
              <Button type="submit" className="sm:order-2 order-1">
                {submitButtonText}
              </Button>
            </DialogFooter>
          </form>
        </Form>
      </DialogContent>
    </Dialog>
  )
}
```

Next, let's create a ThemeToggle component that will allow users to switch between light and dark themes. This component will provide a visual indicator of the current theme and allow users to customize their experience.

```tsx file="components/theme-toggle.tsx"
"use client"

import { Moon, Sun } from "lucide-react"
import { useTheme } from "@/components/theme-provider"
import { Button } from "@/components/ui/button"
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from "@/components/ui/dropdown-menu"

export function ThemeToggle() {
  const { setTheme } = useTheme()

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="outline" size="icon">
          <Sun className="h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0" />
          <Moon className="absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100" />
          <span className="sr-only">Toggle theme</span>
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end">
        <DropdownMenuItem onClick={() => setTheme("light")}>Light</DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme("dark")}>Dark</DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme("system")}>System</DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  )
}
```

Now, let's create an Overview component that will display an overview of tasks and progress. This component will show task statistics, progress charts, and other relevant information.

```tsx file="components/overview.tsx"
"use client"

import { Bar, BarChart, ResponsiveContainer, XAxis, YAxis, Tooltip } from "recharts"
import { useTaskContext } from "@/contexts/task-context"
import { useMemo } from "react"
import dayjs from "dayjs"

const CustomTooltip = ({ active, payload, coordinate }: any) => {
  if (!active || !payload || payload.length === 0) return null

  const tooltipX = coordinate.x
  const tooltipY = 250

  return (
    <div
      className="bg-white text-black border border-gray-300 rounded-md p-4 shadow-md"
      style={{
        position: "absolute",
        left: `${tooltipX}px`,
        top: `${tooltipY}px`,
        pointerEvents: "none",
        transform: "translate(-50%,-100%)",
      }}
    >
      <p className="text-sm font-semibold">{payload[0].payload.name}</p>
      <p className="text-xs whitespace-nowrap">Done: {payload[1]?.value}</p>
      <p className="text-xs whitespace-nowrap">Total: {payload[0]?.value}</p>
    </div>
  )
}

export function Overview() {
  const { tasks } = useTaskContext()

  const data = useMemo(() => {
    const daysOfWeek = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]

    const groupedData = daysOfWeek.reduce(
      (acc, day) => {
        acc[day] = { name: day, completed: 0, total: 0 }
        return acc
      },
      {} as Record<string, { name: string; completed: number; total: number }>,
    )

    tasks.forEach((task) => {
      const dayName = dayjs(task.dueDate).format("ddd")
      if (groupedData[dayName]) {
        groupedData[dayName].total += 1
        if (task.status === "completed") {
          groupedData[dayName].completed += 1
        }
      }
    })

    return Object.values(groupedData)
  }, [tasks])

  return (
    <div className="relative">
      <ResponsiveContainer width="100%" height={350}>
        <BarChart data={data} margin={{ left: -30 }}>
          <XAxis dataKey="name" stroke="#888888" fontSize={12} tickLine={false} axisLine={false} />
          <YAxis stroke="#888888" fontSize={12} tickLine={false} axisLine={false} />
          <Tooltip content={<CustomTooltip />} cursor={{ fill: "transparent" }} />

          <Bar
            dataKey="total"
            fill="currentColor"
            radius={[4, 4, 0, 0]}
            className="fill-primary-400 opacity-30 dark:fill-gray-500 dark:opacity-70"
          />
          <Bar dataKey="completed" fill="currentColor" radius={[4, 4, 0, 0]} className="fill-primary" />
        </BarChart>
      </ResponsiveContainer>
    </div>
  )
}
```

Next, let's create an AlertDialogContext provider that will manage the state and actions related to alert dialogs. This context will allow components to display alert messages and notifications.

```tsx file="contexts/alert-dialog-context.tsx"
"use client"
import { createContext, useContext, useState, type ReactNode } from "react"

interface AlertDialogOptions {
  title: string
  description: string
  onConfirm: () => void
}

interface AlertDialogContextType {
  showDialog: (options: AlertDialogOptions) => void
  hideDialog: () => void
  isOpen: boolean
  options: AlertDialogOptions | null
}

export const AlertDialogContext = createContext<AlertDialogContextType | undefined>(undefined)

export function AlertDialogProvider({ children }: { children: ReactNode }) {
  const [isOpen, setIsOpen] = useState(false)
  const [options, setOptions] = useState<AlertDialogOptions | null>(null)

  const showDialog = (options: AlertDialogOptions) => {
    setOptions(options)
    setIsOpen(true)
  }

  const hideDialog = () => {
    setIsOpen(false)
    setOptions(null)
  }

  return (
    <AlertDialogContext.Provider value={{ isOpen, showDialog, hideDialog, options }}>
      {children}
    </AlertDialogContext.Provider>
  )
}

export function useAlertDialog() {
  const context = useContext(AlertDialogContext)
  if (!context) {
    throw new Error("useAlertDialog must be used within an AlertDialogProvider")
  }
  return context
}
```

Next, let's create a TaskContext provider that will manage the state and actions related to tasks. This context will allow components to access and update task data across the application.

```tsx file="contexts/task-context.tsx"
"use client"

import { createContext, useContext, useState, type ReactNode, useRef, useEffect } from "react"

type Task = {
  id: string
  title: string
  assignee: string
  dueDate: string
  status: "pending" | "completed"
  recurring: string
  createdAt?: string
}

type TaskStats = {
  totalTasks: number
  completedTasks: number
  pendingTasks: number
  completionRate: number
  byAssignee: Record<string, { total: number; completed: number }>
}

type DeletedTaskInfo = {
  task: Task
  index: number
}

type TaskContextType = {
  tasks: Task[]
  stats: TaskStats
  addTask: (task: Task) => void
  updateTask: (id: string, updatedTask: Partial<Task>) => void
  deleteTask: (id: string) => void
  restoreTask: () => void
}

const TaskContext = createContext<TaskContextType | undefined>(undefined)

const initialTasks: Task[] = [
  {
    id: "1",
    title: "Take out the trash",
    assignee: "Dad",
    dueDate: "2023-05-15",
    status: "completed",
    recurring: "weekly",
    createdAt: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString(),
  },
  {
    id: "2",
    title: "Do the dishes",
    assignee: "Emma",
    dueDate: "2023-05-14",
    status: "pending",
    recurring: "daily",
    createdAt: new Date(Date.now() - 5 * 24 * 60 * 60 * 1000).toISOString(),
  },
  {
    id: "3",
    title: "Vacuum living room",
    assignee: "Mom",
    dueDate: "2023-05-16",
    status: "pending",
    recurring: "weekly",
    createdAt: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000).toISOString(),
  },
  {
    id: "4",
    title: "Mow the lawn",
    assignee: "Dad",
    dueDate: "2023-05-20",
    status: "pending",
    recurring: "biweekly",
    createdAt: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString(),
  },
  {
    id: "5",
    title: "Clean bedroom",
    assignee: "Jack",
    dueDate: "2023-05-13",
    status: "completed",
    recurring: "weekly",
    createdAt: new Date(Date.now() - 10 * 24 * 60 * 60 * 1000).toISOString(),
  },
  {
    id: "6",
    title: "Buy groceries",
    assignee: "Mom",
    dueDate: "2023-05-13",
    status: "completed",
    recurring: "weekly",
    createdAt: new Date(Date.now() - 8 * 24 * 60 * 60 * 1000).toISOString(),
  },
]

type TaskProviderProps = {
  children: ReactNode
}

export function TaskProvider({ children }: TaskProviderProps) {
  const [tasks, setTasks] = useState<Task[]>(initialTasks)
  const [stats, setStats] = useState<TaskStats>({
    totalTasks: 0,
    completedTasks: 0,
    pendingTasks: 0,
    completionRate: 0,
    byAssignee: {},
  })

  // Calculate stats whenever tasks change
  useEffect(() => {
    const totalTasks = tasks.length
    const completedTasks = tasks.filter((task) => task.status === "completed").length
    const pendingTasks = totalTasks - completedTasks
    const completionRate = totalTasks > 0 ? Math.round((completedTasks / totalTasks) * 100) : 0

    // Calculate stats by assignee
    const byAssignee: Record<string, { total: number; completed: number }> = {}

    tasks.forEach((task) => {
      if (!byAssignee[task.assignee]) {
        byAssignee[task.assignee] = { total: 0, completed: 0 }
      }

      byAssignee[task.assignee].total++

      if (task.status === "completed") {
        byAssignee[task.assignee].completed++
      }
    })

    setStats({
      totalTasks,
      completedTasks,
      pendingTasks,
      completionRate,
      byAssignee,
    })
  }, [tasks])

  const addTask = (task: Task) => {
    const newTask = {
      ...task,
      createdAt: new Date().toISOString(),
    }
    setTasks((prevTasks) => [...prevTasks, newTask])
  }

  const updateTask = (id: string, updatedTask: Partial<Task>) => {
    setTasks((prevTasks) => prevTasks.map((task) => (task.id === id ? { ...task, ...updatedTask } : task)))
  }

  const lastDeletedTaskInfo = useRef<DeletedTaskInfo | null>(null)

  const deleteTask = (taskId: string) => {
    const taskIndex = tasks.findIndex((task) => task.id === taskId)
    if (taskIndex === -1) return

    lastDeletedTaskInfo.current = {
      task: tasks[taskIndex],
      index: taskIndex,
    }

    setTasks((prevTasks) => prevTasks.filter((task) => task.id !== taskId))
  }

  const restoreTask = () => {
    if (lastDeletedTaskInfo.current) {
      const { task, index } = lastDeletedTaskInfo.current

      setTasks((prevTasks) => {
        const newTasks = [...prevTasks]

        if (index > newTasks.length) {
          newTasks.push(task)
        } else {
          newTasks.splice(index, 0, task)
        }

        return newTasks
      })

      lastDeletedTaskInfo.current = null
    }
  }

  return (
    <TaskContext.Provider value={{ tasks, stats, addTask, updateTask, deleteTask, restoreTask }}>
      {children}
    </TaskContext.Provider>
  )
}

export function useTaskContext() {
  const context = useContext(TaskContext)
  if (!context) {
    throw new Error("useTaskContext must be used within a TaskProvider")
  }
  return context
}
```

Next, let's update the Layout component to include the new components we've created. This component will serve as the main layout for our application and provide a consistent structure for our pages.

```tsx file="app/layout.tsx"
import type React from "react"
import "@/app/globals.css"
import { Inter } from "next/font/google"
import { ThemeProvider } from "@/components/theme-provider"
import { Toaster } from "@/components/ui/sonner"
import { AlertDialogProvider } from "@/contexts/alert-dialog-context"
import { GlobalAlertDialog } from "@/components/global-alert-dialog"
import { TaskProvider } from "@/contexts/task-context"

const inter = Inter({ subsets: ["latin"] })

export const metadata = {
  title: "Family Task Manager",
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body className={inter.className}>
        <AlertDialogProvider>
          <TaskProvider>
            <ThemeProvider defaultTheme="light" storageKey="family-tasks-theme">
              {children}
              <Toaster />
              <GlobalAlertDialog />
            </ThemeProvider>
          </TaskProvider>
        </AlertDialogProvider>
      </body>
    </html>
  )
}
```

Finally, let's update the Home component to include the new components we've created. This component will serve as the main page template for our application and help us organize our content effectively.

```tsx file="app/page.tsx"
"use client"
import Link from "next/link"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { RecentTasks } from "@/components/recent-tasks"
import { FamilyProgress } from "@/components/family-progress"
import { ThemeToggle } from "@/components/theme-toggle"
import { useAlertDialog } from "@/contexts/alert-dialog-context"
import { Search } from "lucide-react"
import { Input } from "@/components/ui/input"
import { useState, useMemo } from "react"
import { TaskModal } from "@/components/task-modal"
import { useTaskContext } from "@/contexts/task-context"

export default function DashboardPage() {
  const { showDialog } = useAlertDialog()
  const [searchQuery, setSearchQuery] = useState("")
  const [isCreateModalOpen, setIsCreateModalOpen] = useState(false)
  const { tasks } = useTaskContext()

  const stats = useMemo(() => {
    const totalTasks = tasks.length
    const completedTasks = tasks.filter((task) => task.status === "completed").length
    const pendingTasks = totalTasks - completedTasks
    const completionRate = totalTasks > 0 ? Math.round((completedTasks / totalTasks) * 100) : 0

    const changeFromLastWeek = {
      total: "+2",
      completed: "+4",
      pending: "-2",
      rate: "+5%",
    }

    return {
      totalTasks,
      completedTasks,
      pendingTasks,
      completionRate,
      changeFromLastWeek,
    }
  }, [tasks])

  return (
    <div className="flex min-h-screen flex-col">
      <header className="sticky top-0 z-10 border-b bg-background">
        <div className="flex h-16 items-center px-4 sm:px-6">
          <div className="flex items-center gap-2 font-semibold">
            <Link href="/">
              <span className="text-lg">FamilyTasks</span>
            </Link>
          </div>
          <nav className="ml-auto flex items-center gap-4 sm:gap-6">
            <ThemeToggle />
          </nav>
        </div>
      </header>
      <main className="flex-1 space-y-4 p-4 pt-6 sm:p-6 sm:pt-8">
        <div className="container mx-auto max-w-6xl px-4 sm:px-6 lg:px-8">
          <div className="flex flex-col sm:flex-row items-start sm:items-center justify-between gap-4">
            <div>
              <h1 className="text-3xl font-bold tracking-tight">Dashboard</h1>
              <p className="text-muted-foreground">Manage your family's tasks and track progress.</p>
            </div>
            <div className="flex">
              <Button onClick={() => setIsCreateModalOpen(true)}>Create New Task</Button>
            </div>
          </div>
          <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-4 mt-6">
            <Card>
              <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                <CardTitle className="text-sm font-medium">Total Tasks</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="text-2xl font-bold">{stats.totalTasks}</div>
                <p className="text-xs text-muted-foreground">{stats.changeFromLastWeek.total} from last week</p>
              </CardContent>
            </Card>
            <Card>
              <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                <CardTitle className="text-sm font-medium">Completed Tasks</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="text-2xl font-bold">{stats.completedTasks}</div>
                <p className="text-xs text-muted-foreground">{stats.changeFromLastWeek.completed} from last week</p>
              </CardContent>
            </Card>
            <Card>
              <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                <CardTitle className="text-sm font-medium">Pending Tasks</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="text-2xl font-bold">{stats.pendingTasks}</div>
                <p className="text-xs text-muted-foreground">{stats.changeFromLastWeek.pending} from last week</p>
              </CardContent>
            </Card>
            <Card>
              <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                <CardTitle className="text-sm font-medium">Completion Rate</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="text-2xl font-bold">{stats.completionRate}%</div>
                <p className="text-xs text-muted-foreground">{stats.changeFromLastWeek.rate} from last week</p>
              </CardContent>
            </Card>
          </div>
          <div className="grid gap-4 md:grid-cols-7 mt-6">
            <Card className="md:col-span-7 col-span-4">
              <CardHeader>
                <CardTitle>Family Progress</CardTitle>
                <CardDescription>Task completion by family member</CardDescription>
              </CardHeader>
              <CardContent>
                <FamilyProgress />
              </CardContent>
            </Card>
          </div>
          <Card className="flex flex-col mt-6">
            <CardHeader>
              <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4">
                <div>
                  <CardTitle>All Tasks</CardTitle>
                  <CardDescription>Manage and track your family's tasks</CardDescription>
                </div>
                <div className="relative w-full sm:w-64">
                  <Search className="absolute left-2 top-2.5 h-4 w-4 text-muted-foreground" />
                  <Input
                    placeholder="Search tasks..."
                    className="pl-8"
                    value={searchQuery}
                    onChange={(e) => setSearchQuery(e.target.value)}
                  />
                </div>
              </div>
            </CardHeader>
            <CardContent className="flex-1 overflow-y-auto">
              <RecentTasks searchQuery={searchQuery} />
            </CardContent>
          </Card>
        </div>
      </main>

      <TaskModal open={isCreateModalOpen} onOpenChange={setIsCreateModalOpen} mode="create" />
    </div>
  )
}
```

Next, let's create a Loading component that will display a loading spinner while fetching data. This component will provide visual feedback to users and improve the user experience during data loading.

```tsx file="app/loading.tsx"
export default function Loading() {
  return null
}
```

Finally, let's create a Family page that will display family tasks and progress. This page will show family achievements, task lists, and progress charts based on the family context.

```tsx file="app/family/page.tsx"
"use client"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card"
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar"
import { Progress } from "@/components/ui/progress"
import { Badge } from "@/components/ui/badge"
import { Plus, Trash2 } from "lucide-react"
import { ThemeToggle } from "@/components/theme-toggle"
import { TaskModal } from "@/components/task-modal"
import { useState } from "react"

const familyMembers = [
  {
    id: "1",
    name: "Mom",
    email: "mom@example.com",
    tasksCompleted: 12,
    totalTasks: 15,
    recentTasks: ["Clean kitchen", "Pay bills", "Grocery shopping"],
  },
  {
    id: "2",
    name: "Dad",
    email: "dad@example.com",
    tasksCompleted: 10,
    totalTasks: 14,
    recentTasks: ["Mow lawn", "Fix sink", "Take out trash"],
  },
  {
    id: "3",
    name: "Emma",
    email: "emma@example.com",
    tasksCompleted: 8,
    totalTasks: 10,
    recentTasks: ["Do homework", "Clean room", "Feed pet"],
  },
  {
    id: "4",
    name: "Jack",
    email: "jack@example.com",
    tasksCompleted: 6,
    totalTasks: 8,
    recentTasks: ["Take out recycling", "Clean room", "Fold laundry"],
  },
]

export default function FamilyPage() {
  const [isCreateModalOpen, setIsCreateModalOpen] = useState(false)

  return (
    <div className="flex min-h-screen flex-col">
      <header className="sticky top-0 z-10 border-b bg-background">
        <div className="flex h-16 items-center px-4 sm:px-6">
          <div className="flex items-center gap-2 font-semibold">
            <span className="text-lg">FamilyTasks</span>
          </div>
          <div className="ml-auto">
            <ThemeToggle />
          </div>
        </div>
      </header>
      <main className="flex-1 space-y-4 p-4 pt-6 sm:p-6 sm:pt-8">
        <div className="container mx-auto max-w-6xl px-4 sm:px-6 lg:px-8">
          <div className="flex flex-col sm:flex-row items-start sm:items-center justify-between gap-4">
            <div>
              <h1 className="text-3xl font-bold tracking-tight">Family Members</h1>
              <p className="text-muted-foreground">Manage family members and their tasks</p>
            </div>
            <Button onClick={() => setIsCreateModalOpen(true)}>
              <Plus className="mr-2 h-4 w-4" /> Add Family Member
            </Button>
          </div>

          <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3 mt-6">
            {familyMembers.map((member) => (
              <Card key={member.id}>
                <CardHeader className="flex flex-row items-center gap-4">
                  <Avatar className="h-14 w-14">
                    <AvatarImage src={`/placeholder.svg?height=56&width=56`} alt={member.name} />
                    <AvatarFallback>{member.name.substring(0, 2).toUpperCase()}</AvatarFallback>
                  </Avatar>
                  <div>
                    <CardTitle>{member.name}</CardTitle>
                    <CardDescription>{member.email}</CardDescription>
                  </div>
                </CardHeader>
                <CardContent className="space-y-4">
                  <div className="space-y-2">
                    <div className="flex justify-between text-sm">
                      <span>Task Completion</span>
                      <span>
                        {member.tasksCompleted}/{member.totalTasks}
                      </span>
                    </div>
                    <Progress value={(member.tasksCompleted / member.totalTasks) * 100} />
                  </div>
                  <div className="min-h-64">
                    <h4 className="mb-2 text-sm font-medium">Recent Tasks</h4>
                    <div className="flex flex-wrap gap-2">
                      {member.recentTasks.map((task, i) => (
                        <Badge key={i} variant="secondary">
                          {task}
                        </Badge>
                      ))}
                    </div>
                  </div>
                </CardContent>
                <CardFooter className="flex justify-between">
                  <Button variant="destructive" size="sm">
                    <Trash2 className="mr-2 h-4 w-4" />
                    Remove
                  </Button>
                </CardFooter>
              </Card>
            ))}
          </div>
        </div>
      </main>

      {/* Modal para crear tareas */}
      <TaskModal open={isCreateModalOpen} onOpenChange={setIsCreateModalOpen} mode="create" />
    </div>
  )
}
```

